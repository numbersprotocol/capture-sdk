name: Auto Release

on:
  push:
    branches: [main]
    paths:
      - 'ts/**'
      - 'python/**'
      - '!**/*.md'
      - '!**/README*'

jobs:
  # Check if this commit should trigger a release
  check-release:
    name: Check Release Trigger
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      bump_type: ${{ steps.check.outputs.bump_type }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Check commit message for release trigger
        id: check
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)

          # Skip if commit message contains [skip release] or [no release]
          if echo "$COMMIT_MSG" | grep -qiE '\[(skip release|no release)\]'; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "Skipping release due to commit message"
            exit 0
          fi

          # Skip if this is a release commit (created by this workflow)
          if echo "$COMMIT_MSG" | grep -qE '^chore\(release\):'; then
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "Skipping release commit"
            exit 0
          fi

          # Determine bump type from commit message
          # [major] or BREAKING CHANGE -> major
          # [minor] or feat: -> minor
          # [patch] or fix: or default -> patch
          if echo "$COMMIT_MSG" | grep -qiE '\[major\]|BREAKING CHANGE'; then
            echo "bump_type=major" >> $GITHUB_OUTPUT
          elif echo "$COMMIT_MSG" | grep -qiE '\[minor\]|^feat(\(.+\))?:'; then
            echo "bump_type=minor" >> $GITHUB_OUTPUT
          else
            echo "bump_type=patch" >> $GITHUB_OUTPUT
          fi

          echo "should_release=true" >> $GITHUB_OUTPUT

  # Bump version and create release tag
  bump-and-tag:
    name: Bump Version and Tag
    needs: check-release
    if: needs.check-release.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_version: ${{ steps.bump.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bump version
        id: bump
        run: |
          BUMP_TYPE=${{ needs.check-release.outputs.bump_type }}

          # Get current version
          CURRENT_VERSION=$(python -c "import json; print(json.load(open('ts/package.json'))['version'])")
          echo "Current version: $CURRENT_VERSION"

          # Bump version using sync script
          python scripts/sync-versions.py --bump $BUMP_TYPE

          # Get new version
          NEW_VERSION=$(python -c "import json; print(json.load(open('ts/package.json'))['version'])")
          echo "New version: $NEW_VERSION"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Commit version bump
        run: |
          NEW_VERSION=${{ steps.bump.outputs.new_version }}
          git add ts/package.json python/pyproject.toml python/numbersprotocol_capture/__init__.py
          git commit -m "chore(release): bump version to $NEW_VERSION"
          git push origin main

      - name: Create and push tag
        run: |
          NEW_VERSION=${{ steps.bump.outputs.new_version }}
          git tag "v$NEW_VERSION"
          git push origin "v$NEW_VERSION"

  # The release.yml workflow will be triggered by the new tag
  notify:
    name: Notify Release Triggered
    needs: [check-release, bump-and-tag]
    if: needs.check-release.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Release triggered
        run: |
          echo "Release v${{ needs.bump-and-tag.outputs.new_version }} has been triggered"
          echo "The release.yml workflow will handle publishing to npm and PyPI"
